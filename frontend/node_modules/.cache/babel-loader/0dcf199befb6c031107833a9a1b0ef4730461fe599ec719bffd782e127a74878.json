{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport axios from 'axios';\nconst API_BASE = process.env.REACT_APP_BACKEND_URL;\n\n// Hook personnalisé pour détecter et récupérer les métadonnées des liens\nexport const useLinkDetection = (text, debounceMs = 1000) => {\n  _s();\n  const [detectedLinks, setDetectedLinks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [removedLinks, setRemovedLinks] = useState(new Set());\n  useEffect(() => {\n    if (!text || text.trim().length === 0) {\n      setDetectedLinks([]);\n      return;\n    }\n    const timer = setTimeout(async () => {\n      try {\n        setLoading(true);\n        const response = await axios.post(`${API_BASE}/api/text/extract-links`, {\n          text: text\n        });\n        const newLinks = response.data.links || [];\n\n        // Filtrer les liens supprimés manuellement\n        const filteredLinks = newLinks.filter(link => !removedLinks.has(link.url));\n        setDetectedLinks(filteredLinks);\n      } catch (error) {\n        console.error('Error detecting links:', error);\n        setDetectedLinks([]);\n      } finally {\n        setLoading(false);\n      }\n    }, debounceMs);\n    return () => clearTimeout(timer);\n  }, [text, debounceMs, removedLinks]);\n  const removeLink = url => {\n    setRemovedLinks(prev => new Set([...prev, url]));\n    setDetectedLinks(prev => prev.filter(link => link.url !== url));\n  };\n  const resetRemovedLinks = () => {\n    setRemovedLinks(new Set());\n  };\n  return {\n    detectedLinks,\n    loading,\n    removeLink,\n    resetRemovedLinks\n  };\n};\n\n// Utilitaire pour détecter les URLs dans du texte (côté client)\n_s(useLinkDetection, \"l/SjT6FfyqGftTtD0/Xsy+n8Ggo=\");\nexport const detectUrlsInText = text => {\n  const urlRegex = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/g;\n  return text.match(urlRegex) || [];\n};\n\n// Hook pour prévisualiser un lien unique\nexport const useLinkPreview = url => {\n  _s2();\n  const [linkData, setLinkData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    if (!url) {\n      setLinkData(null);\n      setError(null);\n      return;\n    }\n    const fetchLinkPreview = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const response = await axios.post(`${API_BASE}/api/links/preview`, {\n          url: url\n        });\n        setLinkData(response.data.metadata);\n      } catch (err) {\n        var _err$response, _err$response$data;\n        console.error('Error fetching link preview:', err);\n        setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.detail) || 'Erreur lors de la récupération de l\\'aperçu');\n        setLinkData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchLinkPreview();\n  }, [url]);\n  return {\n    linkData,\n    loading,\n    error\n  };\n};\n_s2(useLinkPreview, \"YLpn0iNMSOfgSsKoJ4fyoHLWzRo=\");","map":{"version":3,"names":["useState","useEffect","axios","API_BASE","process","env","REACT_APP_BACKEND_URL","useLinkDetection","text","debounceMs","_s","detectedLinks","setDetectedLinks","loading","setLoading","removedLinks","setRemovedLinks","Set","trim","length","timer","setTimeout","response","post","newLinks","data","links","filteredLinks","filter","link","has","url","error","console","clearTimeout","removeLink","prev","resetRemovedLinks","detectUrlsInText","urlRegex","match","useLinkPreview","_s2","linkData","setLinkData","setError","fetchLinkPreview","metadata","err","_err$response","_err$response$data","detail"],"sources":["/app/frontend/src/hooks/useLinkDetection.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst API_BASE = process.env.REACT_APP_BACKEND_URL;\n\n// Hook personnalisé pour détecter et récupérer les métadonnées des liens\nexport const useLinkDetection = (text, debounceMs = 1000) => {\n  const [detectedLinks, setDetectedLinks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [removedLinks, setRemovedLinks] = useState(new Set());\n\n  useEffect(() => {\n    if (!text || text.trim().length === 0) {\n      setDetectedLinks([]);\n      return;\n    }\n\n    const timer = setTimeout(async () => {\n      try {\n        setLoading(true);\n        \n        const response = await axios.post(`${API_BASE}/api/text/extract-links`, {\n          text: text\n        });\n\n        const newLinks = response.data.links || [];\n        \n        // Filtrer les liens supprimés manuellement\n        const filteredLinks = newLinks.filter(link => !removedLinks.has(link.url));\n        \n        setDetectedLinks(filteredLinks);\n      } catch (error) {\n        console.error('Error detecting links:', error);\n        setDetectedLinks([]);\n      } finally {\n        setLoading(false);\n      }\n    }, debounceMs);\n\n    return () => clearTimeout(timer);\n  }, [text, debounceMs, removedLinks]);\n\n  const removeLink = (url) => {\n    setRemovedLinks(prev => new Set([...prev, url]));\n    setDetectedLinks(prev => prev.filter(link => link.url !== url));\n  };\n\n  const resetRemovedLinks = () => {\n    setRemovedLinks(new Set());\n  };\n\n  return {\n    detectedLinks,\n    loading,\n    removeLink,\n    resetRemovedLinks\n  };\n};\n\n// Utilitaire pour détecter les URLs dans du texte (côté client)\nexport const detectUrlsInText = (text) => {\n  const urlRegex = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/g;\n  return text.match(urlRegex) || [];\n};\n\n// Hook pour prévisualiser un lien unique\nexport const useLinkPreview = (url) => {\n  const [linkData, setLinkData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!url) {\n      setLinkData(null);\n      setError(null);\n      return;\n    }\n\n    const fetchLinkPreview = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await axios.post(`${API_BASE}/api/links/preview`, {\n          url: url\n        });\n\n        setLinkData(response.data.metadata);\n      } catch (err) {\n        console.error('Error fetching link preview:', err);\n        setError(err.response?.data?.detail || 'Erreur lors de la récupération de l\\'aperçu');\n        setLinkData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchLinkPreview();\n  }, [url]);\n\n  return { linkData, loading, error };\n};"],"mappings":";;AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,OAAOC,KAAK,MAAM,OAAO;AAEzB,MAAMC,QAAQ,GAAGC,OAAO,CAACC,GAAG,CAACC,qBAAqB;;AAElD;AACA,OAAO,MAAMC,gBAAgB,GAAGA,CAACC,IAAI,EAAEC,UAAU,GAAG,IAAI,KAAK;EAAAC,EAAA;EAC3D,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGZ,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAACa,OAAO,EAAEC,UAAU,CAAC,GAAGd,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACe,YAAY,EAAEC,eAAe,CAAC,GAAGhB,QAAQ,CAAC,IAAIiB,GAAG,CAAC,CAAC,CAAC;EAE3DhB,SAAS,CAAC,MAAM;IACd,IAAI,CAACO,IAAI,IAAIA,IAAI,CAACU,IAAI,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;MACrCP,gBAAgB,CAAC,EAAE,CAAC;MACpB;IACF;IAEA,MAAMQ,KAAK,GAAGC,UAAU,CAAC,YAAY;MACnC,IAAI;QACFP,UAAU,CAAC,IAAI,CAAC;QAEhB,MAAMQ,QAAQ,GAAG,MAAMpB,KAAK,CAACqB,IAAI,CAAC,GAAGpB,QAAQ,yBAAyB,EAAE;UACtEK,IAAI,EAAEA;QACR,CAAC,CAAC;QAEF,MAAMgB,QAAQ,GAAGF,QAAQ,CAACG,IAAI,CAACC,KAAK,IAAI,EAAE;;QAE1C;QACA,MAAMC,aAAa,GAAGH,QAAQ,CAACI,MAAM,CAACC,IAAI,IAAI,CAACd,YAAY,CAACe,GAAG,CAACD,IAAI,CAACE,GAAG,CAAC,CAAC;QAE1EnB,gBAAgB,CAACe,aAAa,CAAC;MACjC,CAAC,CAAC,OAAOK,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9CpB,gBAAgB,CAAC,EAAE,CAAC;MACtB,CAAC,SAAS;QACRE,UAAU,CAAC,KAAK,CAAC;MACnB;IACF,CAAC,EAAEL,UAAU,CAAC;IAEd,OAAO,MAAMyB,YAAY,CAACd,KAAK,CAAC;EAClC,CAAC,EAAE,CAACZ,IAAI,EAAEC,UAAU,EAAEM,YAAY,CAAC,CAAC;EAEpC,MAAMoB,UAAU,GAAIJ,GAAG,IAAK;IAC1Bf,eAAe,CAACoB,IAAI,IAAI,IAAInB,GAAG,CAAC,CAAC,GAAGmB,IAAI,EAAEL,GAAG,CAAC,CAAC,CAAC;IAChDnB,gBAAgB,CAACwB,IAAI,IAAIA,IAAI,CAACR,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACE,GAAG,KAAKA,GAAG,CAAC,CAAC;EACjE,CAAC;EAED,MAAMM,iBAAiB,GAAGA,CAAA,KAAM;IAC9BrB,eAAe,CAAC,IAAIC,GAAG,CAAC,CAAC,CAAC;EAC5B,CAAC;EAED,OAAO;IACLN,aAAa;IACbE,OAAO;IACPsB,UAAU;IACVE;EACF,CAAC;AACH,CAAC;;AAED;AAAA3B,EAAA,CArDaH,gBAAgB;AAsD7B,OAAO,MAAM+B,gBAAgB,GAAI9B,IAAI,IAAK;EACxC,MAAM+B,QAAQ,GAAG,sGAAsG;EACvH,OAAO/B,IAAI,CAACgC,KAAK,CAACD,QAAQ,CAAC,IAAI,EAAE;AACnC,CAAC;;AAED;AACA,OAAO,MAAME,cAAc,GAAIV,GAAG,IAAK;EAAAW,GAAA;EACrC,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAG5C,QAAQ,CAAC,IAAI,CAAC;EAC9C,MAAM,CAACa,OAAO,EAAEC,UAAU,CAAC,GAAGd,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACgC,KAAK,EAAEa,QAAQ,CAAC,GAAG7C,QAAQ,CAAC,IAAI,CAAC;EAExCC,SAAS,CAAC,MAAM;IACd,IAAI,CAAC8B,GAAG,EAAE;MACRa,WAAW,CAAC,IAAI,CAAC;MACjBC,QAAQ,CAAC,IAAI,CAAC;MACd;IACF;IAEA,MAAMC,gBAAgB,GAAG,MAAAA,CAAA,KAAY;MACnC,IAAI;QACFhC,UAAU,CAAC,IAAI,CAAC;QAChB+B,QAAQ,CAAC,IAAI,CAAC;QAEd,MAAMvB,QAAQ,GAAG,MAAMpB,KAAK,CAACqB,IAAI,CAAC,GAAGpB,QAAQ,oBAAoB,EAAE;UACjE4B,GAAG,EAAEA;QACP,CAAC,CAAC;QAEFa,WAAW,CAACtB,QAAQ,CAACG,IAAI,CAACsB,QAAQ,CAAC;MACrC,CAAC,CAAC,OAAOC,GAAG,EAAE;QAAA,IAAAC,aAAA,EAAAC,kBAAA;QACZjB,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEgB,GAAG,CAAC;QAClDH,QAAQ,CAAC,EAAAI,aAAA,GAAAD,GAAG,CAAC1B,QAAQ,cAAA2B,aAAA,wBAAAC,kBAAA,GAAZD,aAAA,CAAcxB,IAAI,cAAAyB,kBAAA,uBAAlBA,kBAAA,CAAoBC,MAAM,KAAI,6CAA6C,CAAC;QACrFP,WAAW,CAAC,IAAI,CAAC;MACnB,CAAC,SAAS;QACR9B,UAAU,CAAC,KAAK,CAAC;MACnB;IACF,CAAC;IAEDgC,gBAAgB,CAAC,CAAC;EACpB,CAAC,EAAE,CAACf,GAAG,CAAC,CAAC;EAET,OAAO;IAAEY,QAAQ;IAAE9B,OAAO;IAAEmB;EAAM,CAAC;AACrC,CAAC;AAACU,GAAA,CAnCWD,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}